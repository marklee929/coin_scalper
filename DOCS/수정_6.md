너는 Binance Spot 자동매매 봇(coin_scalper)의 리팩터링을 담당한다.
목표는 “JSON 파일 폭탄”을 제거하고, 기존에 쌓인 JSON 로그/상태 파일을 정리(마이그레이션)하면서,
향후에는 SQLite 단일 DB(storage/bot.db)로 이벤트/체결/스냅샷을 저장하는 구조로 전환하는 것이다.

[핵심 전제]
- 봇 상태(state)는 메모리에서 운용한다.
- 저장(persist)은 SQLite로 한다. 파일 생성은 최소화한다.
- 기존 JSON 파일들은 1회 마이그레이션 후 아카이빙/삭제 가능하게 한다.
- 전략 자체(눌림/횡보/진입/종료)는 변경하지 않는다. 저장/로깅/상태관리만 바꾼다.

[현재 문제]
- logs/ 또는 storage/에 이벤트마다 JSON 파일이 생성되어 파일이 너무 많다.
- GitHub push가 막힐 정도로 로그 파일이 커진다.
- 프로세스 재시작 시 상태 복구가 불완전하거나 분산된 파일 때문에 관리가 어렵다.

[원하는 최종 구조]
- SQLite 파일: storage/bot.db (단일 파일)
- 테이블은 최소 4개:
  1) trade_log: 체결(매수/매도) 기록
  2) event_log: 구조 판단/진입신호/종료신호/에러 등 이벤트 기록
  3) positions: 현재 오픈 포지션(또는 포지션 히스토리)
  4) snapshots: 주기적 상태 스냅샷(JSON 문자열로 저장 가능)

- state_snapshot 저장 정책:
  - 매 틱마다 저장 금지
  - N초(예: 60초)마다 또는 “상태 변화 이벤트” 발생 시에만 snapshots에 기록
- trade_log/event_log는 append 방식으로 계속 누적
- 향후 백테스트/리포트/디버깅이 쉽게 조회되도록 인덱스 설계 포함

[마이그레이션 요구사항]
1) 기존 JSON 파일들의 위치를 스캔해 형식을 자동 판별하고, 가능한 범위에서 SQLite로 이관한다.
   - 예: universe_YYYY-MM-DD.json / watchlist_*.json / positions_*.json / logs/*.json 등
2) 파일명이 날짜를 포함하면 날짜를 추출해 ts 컬럼에 반영한다.
3) 파싱 실패한 JSON은 event_log에 type="MIGRATION_ERROR"로 기록하고 원본 파일명/에러메시지 남긴다.
4) 마이그레이션 완료 후:
   - 원본 JSON 파일은 storage/archive/로 이동(옵션)
   - 또는 사용자 설정에 따라 삭제 가능

[구현 요구사항]
- Python만 사용 (표준 sqlite3 사용)
- 모듈 분리:
  - storage/db.py : DB 연결, 테이블 생성, insert 함수들
  - storage/migrate_json_to_sqlite.py : 기존 JSON 마이그레이션 스크립트(1회 실행)
  - storage/repo.py : 애플리케이션에서 쓰는 저장 레이어(append_event, append_trade, upsert_position, save_snapshot)
- main 루프에서는 JSON 파일 생성 로직을 제거하고, repo.py만 호출하도록 변경
- 로깅은 콘솔 로그는 유지하되, 저장은 SQLite로만 한다.

[테이블 스키마 초안]
- trade_log(
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    ts TEXT NOT NULL,
    symbol TEXT NOT NULL,
    side TEXT NOT NULL,              -- BUY/SELL
    qty REAL NOT NULL,
    price REAL,
    quote_qty REAL,                  -- USDT 기준 체결금액
    fee REAL,
    fee_asset TEXT,
    reason TEXT,                     -- ENTRY_SUPPORT / EXIT_TP / EXIT_SB 등
    order_id TEXT,
    raw_json TEXT                    -- 원본 응답 저장(선택)
  )

- event_log(
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    ts TEXT NOT NULL,
    level TEXT NOT NULL,             -- INFO/WARN/ERROR
    type TEXT NOT NULL,              -- SCAN/WATCH/ENTRY/EXIT/MIGRATION_ERROR/API_ERROR 등
    symbol TEXT,
    message TEXT,
    data_json TEXT                   -- 추가 데이터
  )

- positions(
    symbol TEXT PRIMARY KEY,
    status TEXT NOT NULL,            -- OPEN/CLOSED
    qty REAL NOT NULL,
    avg_price REAL,
    entry_ts TEXT,
    exit_ts TEXT,
    last_update_ts TEXT,
    pnl_pct REAL,
    tp_pct REAL,
    sl_rule TEXT,                    -- 구조붕괴 규칙 문자열
    data_json TEXT
  )

- snapshots(
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    ts TEXT NOT NULL,
    kind TEXT NOT NULL,              -- STATE/WATCHLIST/UNIVERSE 등
    data_json TEXT NOT NULL
  )

[인덱스]
- trade_log(ts), trade_log(symbol, ts)
- event_log(ts), event_log(type, ts), event_log(symbol, ts)

[출력물]
1) 위 구조대로 작동하는 코드 파일들 전체(경로 포함) 작성
2) 마이그레이션 실행 방법:
   - python -m storage.migrate_json_to_sqlite --src storage --db storage/bot.db --archive storage/archive
3) 기존 코드에서 JSON 저장하는 부분을 SQLite repo 호출로 교체하는 패치 예시(핵심 함수 기준으로)

[안전/운영]
- DB 파일은 gitignore 대상
- config/와 logs/도 gitignore 유지
- 마이그레이션 중에도 원본 보존(archive) 옵션 제공
- 모든 insert는 실패해도 봇이 죽지 않게 try/except로 event_log에 기록

이 요구사항대로 구현을 시작해라.
불확실한 JSON 포맷은 “최대한 유연하게” 처리하고, 모르는 필드는 raw_json/data_json에 그대로 저장하라.
