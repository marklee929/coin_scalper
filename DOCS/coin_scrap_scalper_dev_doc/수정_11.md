ì¢‹ì•„. ì´ê±´ **ë°˜ë“œì‹œ ë§Œë“¤ì–´ë‘ëŠ” ê²Œ ë§ì•„.** â€œê²½ê°ì‹¬ ìœ ì§€â€ + â€œí•œ ë‹¬ íŒë‹¨ KPIâ€ê°€ ìë™ìœ¼ë¡œ ìŒ“ì—¬.

êµ¬í˜„ì€ í¬ê²Œ 2ê°œë§Œ í•˜ë©´ ë¼:

1. **ìµœê·¼ 3ì‹œê°„** `ì§„ì…/ì²­ì‚° íšŸìˆ˜` + `ì‹¤í˜„ ì†ìµ`ì„ DBì—ì„œ ì§‘ê³„
2. ê·¸ê±¸ **í…”ë ˆê·¸ë¨ìœ¼ë¡œ 3ì‹œê°„ë§ˆë‹¤** ë³´ë‚´ëŠ” ìŠ¤ë ˆë“œ ì¶”ê°€

---

## 1) ì§‘ê³„ ê¸°ì¤€(ì§€ê¸ˆ DB êµ¬ì¡°ì— ë§ì¶°ì„œ)

ë„ˆ DBëŠ” `storage/repo.py` ê¸°ì¤€ìœ¼ë¡œ `event_log`, `positions`, `trade_log`ê°€ ìˆìŒ.

### A. íšŸìˆ˜(ì§„ì…/ì²­ì‚°)ëŠ” event_logê°€ ì œì¼ í™•ì‹¤

* ENTRY: `"ENTRY"`
* ìµì ˆ: `"EXIT_TP"`
* ì†ì ˆ: `"EXIT_SL"`

(hold_watchì—ì„œ ì´ë¯¸ append_eventë¡œ ë‚¨ê¹€)

### B. â€œì´ ìˆ˜ìµ/ì†ì‹¤â€ì€ **2ê°€ì§€ ì¤‘ í•˜ë‚˜**ë¡œ ê³„ì‚°

* **ì¶”ì²œ(ì •í™•)**: `trade_log`ì— BUY/SELLì´ ì œëŒ€ë¡œ ìŒ“ì´ë©´
  â†’ `Î£ SELL quote - Î£ BUY quote`ë¡œ â€œì‹¤í˜„ì†ìµ(USDT)â€ ê³„ì‚° ê°€ëŠ¥
* **ì°¨ì„ (ê°„ë‹¨)**: `positions`ì˜ `pnl_pct`ë¡œ ì§‘ê³„
  â†’ ë‹¨, positionsëŠ” upsertë¼ **ê°™ì€ ì‹¬ë³¼ ì—¬ëŸ¬ ë²ˆ ë§¤ë§¤í•˜ë©´ ëˆ„ì ì´ ë®ì¼ ìˆ˜ ìˆìŒ**

ê·¸ë˜ì„œ â€œì˜¤ëŠ˜ ë‹¹ì¥â€ì€:

* **íšŸìˆ˜ëŠ” event_log**
* **ì†ìµì€ trade_log ìˆìœ¼ë©´ trade_log, ì—†ìœ¼ë©´ positions ê¸°ë°˜(ë¶€ì •í™• í‘œì‹œ)**

---

## 2) í•„ìš”í•œ ì½”ë“œ 1ê°œ: `SRC/utils/telemetry_report.py` ì¶”ê°€

ì•„ë˜ ê·¸ëŒ€ë¡œ ë§Œë“¤ë©´ ë¨.

```python
# SRC/utils/telemetry_report.py
import time
from datetime import datetime, timedelta, timezone
from typing import Optional, Tuple

from storage.db import connect
from utils.telegram import send_telegram_message

KST = timezone(timedelta(hours=9))

REPORT_EVERY_HOURS = 3
DB_PATH: Optional[str] = None  # Noneì´ë©´ storage/bot.db ê¸°ë³¸


def _utc_now_str() -> str:
    return datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")


def _utc_str(dt: datetime) -> str:
    return dt.strftime("%Y-%m-%d %H:%M:%S")


def _sum_event_counts(since_ts_utc: str) -> Tuple[int, int, int]:
    """ENTRY, EXIT_TP, EXIT_SL count"""
    with connect(DB_PATH) as conn:
        entry = conn.execute(
            "SELECT COUNT(*) AS c FROM event_log WHERE type='ENTRY' AND ts >= ?",
            (since_ts_utc,),
        ).fetchone()["c"]
        tp = conn.execute(
            "SELECT COUNT(*) AS c FROM event_log WHERE type='EXIT_TP' AND ts >= ?",
            (since_ts_utc,),
        ).fetchone()["c"]
        sl = conn.execute(
            "SELECT COUNT(*) AS c FROM event_log WHERE type='EXIT_SL' AND ts >= ?",
            (since_ts_utc,),
        ).fetchone()["c"]
    return int(entry), int(tp), int(sl)


def _realized_pnl_from_trade_log(since_ts_utc: str) -> Optional[float]:
    """
    trade_logì— quote_qtyê°€ ë“¤ì–´ìˆìœ¼ë©´:
    realized â‰ˆ sum(SELL.quote_qty) - sum(BUY.quote_qty)
    (í•´ë‹¹ êµ¬ê°„ ì•ˆì—ì„œ ì²´ê²°ëœ ê²ƒë§Œ ì§‘ê³„. ì™„ë²½í•œ FIFO ì •ì‚°ì€ ì•„ë‹˜)
    """
    with connect(DB_PATH) as conn:
        row = conn.execute(
            """
            SELECT
              SUM(CASE WHEN side='SELL' THEN COALESCE(quote_qty, qty*price, 0) ELSE 0 END) AS sell_q,
              SUM(CASE WHEN side='BUY'  THEN COALESCE(quote_qty, qty*price, 0) ELSE 0 END) AS buy_q
            FROM trade_log
            WHERE ts >= ?
            """,
            (since_ts_utc,),
        ).fetchone()

    sell_q = row["sell_q"]
    buy_q = row["buy_q"]
    if sell_q is None and buy_q is None:
        return None
    return float(sell_q or 0) - float(buy_q or 0)


def _fallback_pnl_from_positions(since_ts_utc: str) -> Optional[float]:
    """
    positions í…Œì´ë¸”ì€ upsertë¼ â€˜ëˆ„ì â€™ì´ ì•„ë‹ ìˆ˜ ìˆìŒ.
    ê·¸ë˜ë„ ìµœê·¼ ì¢…ë£Œ í¬ì§€ì…˜ pnl_pctê°€ ìˆë‹¤ë©´ í•©ì‚°í•´ì„œ ì°¸ê³ ì¹˜ë¡œ ì‚¬ìš©.
    """
    with connect(DB_PATH) as conn:
        rows = conn.execute(
            """
            SELECT pnl_pct
            FROM positions
            WHERE status='CLOSED'
              AND exit_ts IS NOT NULL
              AND exit_ts >= ?
              AND pnl_pct IS NOT NULL
            """,
            (since_ts_utc,),
        ).fetchall()

    if not rows:
        return None
    return float(sum([r["pnl_pct"] for r in rows]))


def _next_run_kst(now_kst: datetime) -> datetime:
    # 0,3,6,9,12,15,18,21ì‹œì— ë§ì¶¤
    hour = now_kst.hour
    next_block = ((hour // REPORT_EVERY_HOURS) + 1) * REPORT_EVERY_HOURS
    if next_block >= 24:
        target = (now_kst + timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)
    else:
        target = now_kst.replace(hour=next_block, minute=0, second=0, microsecond=0)
    return target


def send_3h_report_once() -> None:
    now_utc = datetime.utcnow().replace(tzinfo=timezone.utc)
    now_kst = now_utc.astimezone(KST)

    since_utc = now_utc - timedelta(hours=REPORT_EVERY_HOURS)
    since_ts = _utc_str(since_utc.replace(tzinfo=None))  # DBê°€ UTC naive string

    entry, tp, sl = _sum_event_counts(since_ts)

    pnl_quote = _realized_pnl_from_trade_log(since_ts)
    pnl_pct = None
    pnl_note = ""

    if pnl_quote is None:
        pnl_pct = _fallback_pnl_from_positions(since_ts)
        pnl_note = " (positions ê¸°ë°˜, ì°¸ê³ ì¹˜)"
    else:
        pnl_note = " (trade_log ê¸°ë°˜)"

    msg_lines = [
        f"â±ï¸ 3ì‹œê°„ ë¦¬í¬íŠ¸ ({now_kst.strftime('%m/%d %H:%M')} KST)",
        f"ğŸŸ¦ ì§„ì…(ENTRY): {entry}",
        f"ğŸŸ© ìµì ˆ(EXIT_TP): {tp}",
        f"ğŸŸ¥ ì†ì ˆ(EXIT_SL): {sl}",
    ]

    if pnl_quote is not None:
        sign = "+" if pnl_quote >= 0 else ""
        msg_lines.append(f"ğŸ’° ì‹¤í˜„ì†ìµ{pnl_note}: {sign}{pnl_quote:.2f} USDT")
    elif pnl_pct is not None:
        sign = "+" if pnl_pct >= 0 else ""
        msg_lines.append(f"ğŸ’° ì‹¤í˜„ì†ìµ{pnl_note}: {sign}{pnl_pct:.2f}%")
    else:
        msg_lines.append("ğŸ’° ì‹¤í˜„ì†ìµ: ì§‘ê³„ ë°ì´í„° ì—†ìŒ")

    send_telegram_message("\n".join(msg_lines))


def start_3h_reporter_thread() -> None:
    import threading

    def loop():
        while True:
            try:
                send_3h_report_once()
            except Exception:
                # í…”ë ˆê·¸ë¨ ì‹¤íŒ¨ ë“±ì€ ë´‡ì„ ì£½ì´ë©´ ì•ˆ ë¨
                pass

            now_kst = datetime.utcnow().replace(tzinfo=timezone.utc).astimezone(KST)
            nxt = _next_run_kst(now_kst)
            sleep_sec = max(10, int((nxt - now_kst).total_seconds()))
            time.sleep(sleep_sec)

    t = threading.Thread(target=loop, daemon=True)
    t.start()
```

---

## 3) main.pyì— í•œ ì¤„ë§Œ ì¶”ê°€

WS ì‹œì‘í•˜ê³  ìŠ¤ë ˆë“œ ë„ìš´ ë‹¤ìŒ, ë¦¬í¬í„°ë„ ë„ì›Œ.

```python
from utils.telemetry_report import start_3h_reporter_thread

# ... (start_price_stream, start_scalping_threadë“¤ ì‹¤í–‰ í›„)
start_3h_reporter_thread()
```

---

## 4) ì¤‘ìš”í•œ í˜„ì‹¤ ì²´í¬: trade_logê°€ ì‹¤ì œë¡œ ìŒ“ì´ê³  ìˆë‚˜?

ì§€ê¸ˆ `hold_watch.py`ëŠ” `append_event`ëŠ” ì°ëŠ”ë°, `append_trade`ëŠ” ì•ˆ ì°ëŠ” êµ¬ì¡°ì˜€ë˜ ê±¸ë¡œ ê¸°ì–µí•´.
ê·¸ë˜ì„œ â€œì‹¤í˜„ì†ìµ(USDT)â€ì„ ì •í™•íˆ í•˜ë ¤ë©´ **buy_market / sell_market ë‚´ë¶€ì—ì„œ append_tradeë¥¼ ì°ì–´ì¤˜ì•¼ í•¨**.

* ê°€ëŠ¥í•˜ë©´ `order_executor.py`ì—ì„œ

  * BUY ì²´ê²° ì‹œ `append_trade(side='BUY', quote_qty=..., price=..., qty=...)`
  * SELL ì²´ê²° ì‹œ `append_trade(side='SELL', ...)`

ì´ê±° í•œ ë²ˆë§Œ ë¶™ì´ë©´ ì´í›„ë¶€í„° ë¦¬í¬íŠ¸ ì†ìµì´ ì •í™•í•´ì§.

---

ì›í•˜ë©´ ë‹¤ìŒ ë‹¨ê³„ë¡œ:

* `order_executor.py`ì— `append_trade` ìë™ ê¸°ë¡ ë„£ëŠ” íŒ¨ì¹˜(ë§¤ìˆ˜/ë§¤ë„ ëª¨ë‘)
* 3ì‹œê°„ ë¦¬í¬íŠ¸ + â€œì˜¤ëŠ˜ ëˆ„ì  ë¦¬í¬íŠ¸(00:00~í˜„ì¬)â€ë„ ê°™ì´ ë³´ë‚´ê¸°

ì´ ë‘ ê°œê¹Œì§€ í•œ ë²ˆì— ì •ë¦¬í•´ì¤„ê²Œ.
